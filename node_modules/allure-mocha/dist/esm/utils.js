import { dirname, extname, join } from "node:path";
import { fileURLToPath } from "node:url";
import { LabelName } from "allure-js-commons";
import { extractMetadataFromString } from "allure-js-commons/sdk";
import { getRelativePath, md5, parseTestPlan } from "allure-js-commons/sdk/reporter";
var filename = fileURLToPath(import.meta.url);
var allureMochaDataKey = Symbol("Used to access Allure extra data in Mocha objects");
var getAllureData = item => {
  var data = item[allureMochaDataKey];
  if (!data) {
    var meta = extractMetadataFromString(item.title);
    var defaultData = {
      isIncludedInTestRun: true,
      fullName: createAllureFullName(item),
      labels: meta.labels,
      displayName: meta.cleanTitle
    };
    item[allureMochaDataKey] = defaultData;
    return defaultData;
  }
  return data;
};
var createAllureFullName = test => {
  var titlePath = test.titlePath().join(" > ");
  return test.file ? "".concat(getRelativePath(test.file), ": ").concat(titlePath) : titlePath;
};
var createTestPlanSelectorIndex = testplan => createTestPlanIndex(e => e.selector, testplan);
var createTestPlanIdIndex = testplan => createTestPlanIndex(e => {
  var _e$id;
  return (_e$id = e.id) === null || _e$id === void 0 ? void 0 : _e$id.toString();
}, testplan);
var createTestPlanIndex = (keySelector, testplan) => new Set(testplan.tests.map(e => keySelector(e)).filter(v => v));
export var createTestPlanIndices = () => {
  var testplan = parseTestPlan();
  if (testplan) {
    return {
      fullNameIndex: createTestPlanSelectorIndex(testplan),
      idIndex: createTestPlanIdIndex(testplan)
    };
  }
};
export var getAllureFullName = test => getAllureData(test).fullName;
export var isIncludedInTestRun = test => getAllureData(test).isIncludedInTestRun;
export var getAllureMetaLabels = test => getAllureData(test).labels;
export var getAllureId = data => {
  var values = data.labels.filter(l => l.name === LabelName.ALLURE_ID).map(l => l.value);
  if (values.length) {
    return values[0];
  }
};
export var getAllureDisplayName = test => getAllureData(test).displayName;
export var getTestScope = test => getAllureData(test).scope;
export var setTestScope = (test, scope) => {
  getAllureData(test).scope = scope;
};
export var getSuitesOfMochaTest = test => test.titlePath().slice(0, -1);
export var resolveParallelModeSetupFile = () => join(dirname(filename), "setupAllureMochaParallel".concat(extname(filename)));
export var getTestCaseId = test => {
  var suiteTitles = test.titlePath().slice(0, -1);
  return md5(JSON.stringify([...suiteTitles, getAllureDisplayName(test)]));
};
export var applyTestPlan = (ids, selectors, rootSuite) => {
  var suiteQueue = [];
  for (var s = rootSuite; s; s = suiteQueue.shift()) {
    for (var test of s.tests) {
      var allureData = getAllureData(test);
      var allureId = getAllureId(allureData);
      if (!selectors.has(allureData.fullName) && (!allureId || !ids.has(allureId))) {
        allureData.isIncludedInTestRun = false;
        test.pending = true;
      }
    }
    suiteQueue.push(...s.suites);
  }
};
var hookTypeRegexp = /^"(before|after) (all|each)"/;
export var getHookType = hook => {
  if (hook.title) {
    var match = hookTypeRegexp.exec(hook.title);
    if (match) {
      return [match[1], match[2]];
    }
  }
  return [];
};
//# sourceMappingURL=utils.js.map