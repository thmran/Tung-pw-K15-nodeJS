"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.setTestScope = exports.resolveParallelModeSetupFile = exports.isIncludedInTestRun = exports.getTestScope = exports.getTestCaseId = exports.getSuitesOfMochaTest = exports.getHookType = exports.getAllureMetaLabels = exports.getAllureId = exports.getAllureFullName = exports.getAllureDisplayName = exports.createTestPlanIndices = exports.applyTestPlan = void 0;
var _nodePath = require("node:path");
var _nodeUrl = require("node:url");
var _allureJsCommons = require("allure-js-commons");
var _sdk = require("allure-js-commons/sdk");
var _reporter = require("allure-js-commons/sdk/reporter");
var filename = (0, _nodeUrl.fileURLToPath)(require('url').pathToFileURL(__filename).toString());
var allureMochaDataKey = Symbol("Used to access Allure extra data in Mocha objects");
var getAllureData = item => {
  var data = item[allureMochaDataKey];
  if (!data) {
    var meta = (0, _sdk.extractMetadataFromString)(item.title);
    var defaultData = {
      isIncludedInTestRun: true,
      fullName: createAllureFullName(item),
      labels: meta.labels,
      displayName: meta.cleanTitle
    };
    item[allureMochaDataKey] = defaultData;
    return defaultData;
  }
  return data;
};
var createAllureFullName = test => {
  var titlePath = test.titlePath().join(" > ");
  return test.file ? "".concat((0, _reporter.getRelativePath)(test.file), ": ").concat(titlePath) : titlePath;
};
var createTestPlanSelectorIndex = testplan => createTestPlanIndex(e => e.selector, testplan);
var createTestPlanIdIndex = testplan => createTestPlanIndex(e => {
  var _e$id;
  return (_e$id = e.id) === null || _e$id === void 0 ? void 0 : _e$id.toString();
}, testplan);
var createTestPlanIndex = (keySelector, testplan) => new Set(testplan.tests.map(e => keySelector(e)).filter(v => v));
var createTestPlanIndices = () => {
  var testplan = (0, _reporter.parseTestPlan)();
  if (testplan) {
    return {
      fullNameIndex: createTestPlanSelectorIndex(testplan),
      idIndex: createTestPlanIdIndex(testplan)
    };
  }
};
exports.createTestPlanIndices = createTestPlanIndices;
var getAllureFullName = test => getAllureData(test).fullName;
exports.getAllureFullName = getAllureFullName;
var isIncludedInTestRun = test => getAllureData(test).isIncludedInTestRun;
exports.isIncludedInTestRun = isIncludedInTestRun;
var getAllureMetaLabels = test => getAllureData(test).labels;
exports.getAllureMetaLabels = getAllureMetaLabels;
var getAllureId = data => {
  var values = data.labels.filter(l => l.name === _allureJsCommons.LabelName.ALLURE_ID).map(l => l.value);
  if (values.length) {
    return values[0];
  }
};
exports.getAllureId = getAllureId;
var getAllureDisplayName = test => getAllureData(test).displayName;
exports.getAllureDisplayName = getAllureDisplayName;
var getTestScope = test => getAllureData(test).scope;
exports.getTestScope = getTestScope;
var setTestScope = (test, scope) => {
  getAllureData(test).scope = scope;
};
exports.setTestScope = setTestScope;
var getSuitesOfMochaTest = test => test.titlePath().slice(0, -1);
exports.getSuitesOfMochaTest = getSuitesOfMochaTest;
var resolveParallelModeSetupFile = () => (0, _nodePath.join)((0, _nodePath.dirname)(filename), "setupAllureMochaParallel".concat((0, _nodePath.extname)(filename)));
exports.resolveParallelModeSetupFile = resolveParallelModeSetupFile;
var getTestCaseId = test => {
  var suiteTitles = test.titlePath().slice(0, -1);
  return (0, _reporter.md5)(JSON.stringify([...suiteTitles, getAllureDisplayName(test)]));
};
exports.getTestCaseId = getTestCaseId;
var applyTestPlan = (ids, selectors, rootSuite) => {
  var suiteQueue = [];
  for (var s = rootSuite; s; s = suiteQueue.shift()) {
    for (var test of s.tests) {
      var allureData = getAllureData(test);
      var allureId = getAllureId(allureData);
      if (!selectors.has(allureData.fullName) && (!allureId || !ids.has(allureId))) {
        allureData.isIncludedInTestRun = false;
        test.pending = true;
      }
    }
    suiteQueue.push(...s.suites);
  }
};
exports.applyTestPlan = applyTestPlan;
var hookTypeRegexp = /^"(before|after) (all|each)"/;
var getHookType = hook => {
  if (hook.title) {
    var match = hookTypeRegexp.exec(hook.title);
    if (match) {
      return [match[1], match[2]];
    }
  }
  return [];
};
exports.getHookType = getHookType;
//# sourceMappingURL=utils.js.map